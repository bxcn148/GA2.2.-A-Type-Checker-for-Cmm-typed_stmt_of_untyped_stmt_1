Download link :https://programming.engineering/product/ga2-2-a-type-checker-for-cmm-typed_stmt_of_untyped_stmt_1/


# GA2.2.-A-Type-Checker-for-Cmm-typed_stmt_of_untyped_stmt_1
GA2.2. A Type Checker for Cmm – typed_stmt_of_untyped_stmt_1
Write a function update_type_env_with_varDecl : (string * declarable_type) list —> basic_type * varDeclId list —> (string * declarable_type) list that adds a list of variables, all of the same specified type, to the given environment.

Write the mutually recursive pair of functions typed_statement_of_untyped_statement : function_return_type —> (string * declarable_type) list —> (untyped_monop, untyped_binop) statement —> ( (typed_monop, typed_binop) statement * statement_return_possibility) option

and

O typed_compound_statement_of_untyped_compound_statement : function_return_type —> (string * declarable_type) list —> (untyped_monop, untyped_binop) compound_statement —> ((typed_monop, typed_binop) compound_statement * statement_return_possibility) option

that, for each of these functions, is given a type for the expected return type for every return statement contained in the given statement or compound statement, next is given a type environment supplying the declarable_type of a variable of a given name, if it has been declared, and last is given an untyped statement or compound statement. It returns the translation, if possible, of the untyped statement or compound statement into the corresponding type-checked typed statement or compound statement paired with whether it always will return a value of the given return type (WillReturn), may return a value of the given return type but might not (MaybeReturn), or will not return any value (NoReturn). The tranlation is done as follows: If the statement is an assignment statement, look up the type of the assignment variable in the environment, translate the untyped expression whose value will be assigned to the variable, promote the result to the type of the variable, and build the resulting typed assignment statement. The assignment statement is atomic as a statement, and is not a return statement. As such it returns no value. If the statement is an assignment to an array cell, look up the type of the array variable name in the environment, translate both the untyped expression and index expression, promoting them to the array’s element type and int, respectively. If the statement is a standalone expression, translate the untyped expression to a typed expression, return the corresponding typed expression statement, indicating no return value. If the statement is a print statement, translate its untyped expression argument, check that the corresponding typed expression has the type of a character array, and is so, return the corresponding typed expression statement, indicating no return value. If the statement is a return with an expression argument, translate the returned expression, promote it to the expected function return type, and construct a new return statement. If there is no expression argument, the typed return statement also has no argument, but the function return type must be VoidFunTy. For the end result, in either case, the typed return statement should paired with WillReturn. If the statement is a block statement, recursively translate the compound statement to construct a typed block statement using the mutually

c Personal Notes

No attached notes

Attach a file Add text note

(WillReturn), may return a value of the given return type but might not (MaybeReturn), or will not return any value (NoReturn). The tranlation is done as follows: If the statement is an assignment statement, look up the type of the assignment variable in the environment, translate the untyped expression whose value will be assigned to the variable, promote the result to the type of the variable, and build the resulting typed assignment statement. The assignment statement is atomic as a statement, and is not a return statement. As such it returns no value. If the statement is an assignment to an array cell, look up the type of the array variable name in the environment, translate both the untyped expression and index expression, promoting them to the array’s element type and int, respectively. If the statement is a standalone expression, translate the untyped expression to a typed expression, return the corresponding typed expression statement, indicating no return value. If the statement is a print statement, translate its untyped expression argument, check that the corresponding typed expression has the type of a character array, and is so, return the corresponding typed expression statement, indicating no return value. If the statement is a return with an expression argument, translate the returned expression, promote it to the expected function return type, and construct a new return statement. If there is no expression argument, the typed return statement also has no argument, but the function return type must be VoidFunTy. For the end result, in either case, the typed return statement should paired with WillReturn. If the statement is a block statement, recursively translate the compound statement to construct a typed block statement using the mutually recursive function for the compound statement in the block statement. The resulting typed block statement is paired with the value return kind returned for the compound statement. If the statement is an if statement, first translate the untyped guard expression to a typed guard expression and check that the result is of boolean type. If it is, translate the untyped compound “then” statement to a typed compound statement to construct the resulting typed if statement. If the typed compound statement returns no value, then the typed if statement also returns no value. Otherwise, the value return kind is MaybeReturn, since there is always the possibility that the “then” statement will be skipped. While statements are handled the same way as if statements. If the statement is an if-else statement, it is translated as with the if statement, translating the else statement as well. If the value return kinds of the then and else statements are the same, the typed if-else statement is paired with that shared value return kind. Otherwise, the typed if-else statement is paired with MaybeReturn. For compound statements, the environment is updated with all of the variable declarations, and the new environment is used to iteratively translate each statement. The return possibility of the compound statement is the maximum of the return possibilities of each of the statements (using the order WillReturn > MaybeReturn > NoReturn).

Note: ► You will be given in Plsolutions the functions from the cmm_promote and cmm_overload questions:
